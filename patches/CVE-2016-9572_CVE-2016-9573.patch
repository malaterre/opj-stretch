From 7b28bd2b723df6be09fe7791eba33147c1c47d0d Mon Sep 17 00:00:00 2001
From: szukw000 <szukw000@arcor.de>
Date: Mon, 28 Nov 2016 21:57:20 +0100
Subject: [PATCH] Changes for issues #863 and #862

---
 src/bin/jp2/convert.c        | 59 +++++++++++++++++++++++++++++++++++++++-----
 src/bin/jp2/convertbmp.c     | 29 +++++++++++++++++++++-
 src/bin/jp2/opj_decompress.c |  2 +-
 src/lib/openjp2/j2k.c        | 11 ++++++---
 4 files changed, 90 insertions(+), 11 deletions(-)

--- a/src/bin/jp2/convert.c
+++ b/src/bin/jp2/convert.c
@@ -906,7 +906,8 @@
     for (i = 0; i < image->numcomps-1; i++)	{
         if ((image->comps[0].dx != image->comps[i+1].dx)
                 ||(image->comps[0].dy != image->comps[i+1].dy)
-                ||(image->comps[0].prec != image->comps[i+1].prec))	{
+                ||(image->comps[0].prec != image->comps[i+1].prec)
+				||(image->comps[0].sgnd != image->comps[i+1].sgnd))	{
             fclose(fdest);
             fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
             return 1;
@@ -1743,7 +1744,7 @@
     int *red, *green, *blue, *alpha;
     int wr, hr, max;
     int i;
-    unsigned int compno, ncomp;
+    unsigned int compno, ncomp, ui;
     int adjustR, adjustG, adjustB, adjustA;
     int fails, two, want_gray, has_alpha, triple;
     int prec, v;
@@ -1768,6 +1769,27 @@
 
     if(want_gray) ncomp = 1;
 
+    for (ui = 1; ui < ncomp; ++ui) {
+        if (image->comps[0].dx != image->comps[ui].dx) {
+            break;
+        }
+        if (image->comps[0].dy != image->comps[ui].dy) {
+            break;
+        }
+        if (image->comps[0].prec != image->comps[ui].prec) {
+            break;
+        }
+        if (image->comps[0].sgnd != image->comps[ui].sgnd) {
+            break;
+        }
+    }
+    if (ui != ncomp) {
+        fprintf(stderr,"imagetopnm: All components\n    shall have "
+         "the same subsampling, same bit depth, same sign.\n"
+         "    Aborting\n");
+        return 1;
+    }
+
     if ((force_split == 0) &&
 				(ncomp == 2 /* GRAYA */
             || (ncomp > 2 /* RGB, RGBA */
@@ -2126,7 +2148,7 @@
 {
     FILE *rawFile = NULL;
     size_t res;
-    unsigned int compno;
+    unsigned int compno, numcomps;
     int w, h, fails;
     int line, row, curr, mask;
     int *ptr;
@@ -2139,6 +2161,31 @@
         return 1;
     }
 
+    numcomps = image->numcomps;
+
+    if (numcomps > 4) {
+        numcomps = 4;
+    }
+    for (compno = 1; compno < numcomps; ++compno) {
+        if (image->comps[0].dx != image->comps[compno].dx) {
+            break;
+        }
+        if (image->comps[0].dy != image->comps[compno].dy) {
+            break;
+        }
+        if (image->comps[0].prec != image->comps[compno].prec) {
+            break;
+        }
+        if (image->comps[0].sgnd != image->comps[compno].sgnd) {
+            break;
+        }
+    }
+    if (compno != numcomps) {
+        fprintf(stderr,"imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\n");
+        fprintf(stderr,"\tAborting\n");
+        return 1;
+    }
+
     rawFile = fopen(outfile, "wb");
     if (!rawFile) {
         fprintf(stderr, "Failed to open %s for writing !!\n", outfile);
@@ -2146,9 +2193,9 @@
     }
 
     fails = 1;
-    fprintf(stdout,"Raw image characteristics: %d components\n", image->numcomps);
+    fprintf(stdout,"Raw image characteristics: %d components\n", numcomps);
 
-    for(compno = 0; compno < image->numcomps; compno++)
+    for(compno = 0; compno < numcomps; compno++)
     {
         fprintf(stdout,"Component %u characteristics: %dx%dx%d %s\n", compno, image->comps[compno].w,
                 image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? "signed": "unsigned");
@@ -2238,7 +2285,7 @@
         }
         else if (image->comps[compno].prec <= 32)
         {
-            fprintf(stderr,"More than 16 bits per component no handled yet\n");
+            fprintf(stderr,"More than 16 bits per component not handled yet\n");
             goto fin;
         }
         else
--- a/src/bin/jp2/convertbmp.c
+++ b/src/bin/jp2/convertbmp.c
@@ -806,8 +806,35 @@
     FILE *fdest = NULL;
     int adjustR, adjustG, adjustB;
 
+   {
+    unsigned int ui, ncomp = image->numcomps;
+
+    if (ncomp > 4) { /* RGBA in bmpmask32toimage */
+        ncomp = 4;
+    }
+    for (ui = 1; ui < ncomp; ++ui) {
+        if (image->comps[0].dx != image->comps[ui].dx) {
+            break;
+        }
+        if (image->comps[0].dy != image->comps[ui].dy) {
+            break;
+        }
+        if (image->comps[0].prec != image->comps[ui].prec) {
+            break;
+        }
+        if (image->comps[0].sgnd != image->comps[ui].sgnd) {
+            break;
+        }
+    }
+    if (ui != ncomp) {
+        fprintf(stderr,"imagetobmp: All components shall have the same subsampling, same bit depth, same sign.\n");
+        fprintf(stderr,"\tAborting\n");
+        return 1;
+    }
+
+   }
     if (image->comps[0].prec < 8) {
-        fprintf(stderr, "Unsupported number of components: %d\n", image->comps[0].prec);
+        fprintf(stderr, "imagetobmp: Unsupported precision: %d\n", image->comps[0].prec);
         return 1;
     }
     if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx
--- a/src/bin/jp2/opj_decompress.c
+++ b/src/bin/jp2/opj_decompress.c
@@ -1573,7 +1573,7 @@
 		if(dirptr->filename_buf) free(dirptr->filename_buf);
 		free(dirptr);
 	}
-	if (numDecompressedImages) {
+	if (numDecompressedImages && !failed) {
 		fprintf(stdout, "decode time: %d ms\n", (int)( (tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));
 	}
 	return failed ? EXIT_FAILURE : EXIT_SUCCESS;
--- a/src/lib/openjp2/j2k.c
+++ b/src/lib/openjp2/j2k.c
@@ -2158,7 +2158,7 @@
                                   i, l_img_comp->dx, l_img_comp->dy);
                     return OPJ_FALSE;
                 }
-                if( l_img_comp->prec > 38) { /* TODO openjpeg won't handle more than ? */
+                if( l_img_comp->prec < 1 || l_img_comp->prec > 38) { /* TODO openjpeg won't handle more than ? */
                     opj_event_msg(p_manager, EVT_ERROR,
                                   "Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm)\n",
                                   i, l_img_comp->prec);
@@ -9975,7 +9975,11 @@
         /* Move data and copy one information from codec to output image*/
         for (compno = 0; compno < p_image->numcomps; compno++) {
                 p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;
-                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;
+		p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;
+
+		if(p_image->comps[compno].data == NULL) return OPJ_FALSE;
+
+                p_j2k->m_output_image->comps[compno].data = NULL;
 #if 0
                 char fn[256];
                 sprintf( fn, "/tmp/%d.raw", compno );
@@ -9983,7 +9987,6 @@
                 fwrite( p_image->comps[compno].data, sizeof(OPJ_INT32), p_image->comps[compno].w * p_image->comps[compno].h, debug );
                 fclose( debug );
 #endif
-                p_j2k->m_output_image->comps[compno].data = NULL;
         }
 
         return OPJ_TRUE;
@@ -10077,6 +10080,8 @@
 
                 p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;
 
+				if (p_image->comps[compno].data == NULL) return OPJ_FALSE;
+
                 p_j2k->m_output_image->comps[compno].data = NULL;
         }
 
